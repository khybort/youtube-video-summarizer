package transcript

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/google/uuid"
	"go.uber.org/zap"
	"youtube-video-summarizer/backend/internal/models"
	"youtube-video-summarizer/backend/internal/repository"
	"youtube-video-summarizer/backend/internal/services/cost"
	"youtube-video-summarizer/backend/internal/services/provider"
	"youtube-video-summarizer/backend/pkg/errors"
	"youtube-video-summarizer/backend/pkg/whisper"
	"youtube-video-summarizer/backend/pkg/youtube"
)

type Service struct {
	transcriptRepo  repository.TranscriptRepository
	videoRepo       repository.VideoRepository
	providerFactory *provider.ProviderFactory
	youtubeClient   *youtube.Client
	costService     *cost.Service
	logger          *zap.Logger
	tempDir         string
}

func NewService(
	transcriptRepo repository.TranscriptRepository,
	videoRepo repository.VideoRepository,
	providerFactory *provider.ProviderFactory,
	youtubeClient *youtube.Client,
	costService *cost.Service,
	logger *zap.Logger,
) *Service {
	tempDir := os.TempDir()
	return &Service{
		transcriptRepo:  transcriptRepo,
		videoRepo:       videoRepo,
		providerFactory: providerFactory,
		youtubeClient:   youtubeClient,
		costService:     costService,
		logger:          logger,
		tempDir:         tempDir,
	}
}

func (s *Service) GetByVideoID(ctx context.Context, videoID uuid.UUID) (*models.Transcript, error) {
	return s.transcriptRepo.GetByVideoID(ctx, videoID)
}

// AvailableLanguage represents a language available for captions
// This matches the handlers.AvailableLanguage type
type AvailableLanguage struct {
	Code            string `json:"code"`
	Name            string `json:"name"`
	IsAutoGenerated bool   `json:"is_auto_generated"`
}

// ListAvailableLanguages lists all available caption languages for a YouTube video
func (s *Service) ListAvailableLanguages(ctx context.Context, youtubeID string) ([]AvailableLanguage, error) {
	url := fmt.Sprintf("https://www.youtube.com/watch?v=%s", youtubeID)
	
	s.logger.Info("Listing available caption languages", zap.String("youtube_id", youtubeID))
	
	// Use yt-dlp to list available subtitle tracks
	cmd := exec.Command("yt-dlp",
		"--list-subs",        // List available subtitles
		"--no-playlist",      // Don't download playlists
		"--quiet",            // Less verbose output
		"--no-warnings",      // Suppress warnings
		url,
	)
	
	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr
	
	if err := cmd.Run(); err != nil {
		s.logger.Debug("Failed to list subtitles", 
			zap.String("youtube_id", youtubeID),
			zap.String("error", stderr.String()),
			zap.Error(err))
		return nil, fmt.Errorf("failed to list subtitles: %w", err)
	}
	
	// Parse yt-dlp output
	// Format is typically:
	// Available subtitles for <video_id>:
	// Language Name    Formats
	// en       English vtt, ttml, srv3, srv2, srv1, json3
	// tr       Turkish vtt, ttml, srv3, srv2, srv1, json3
	// ...
	output := stdout.String()
	languages := parseLanguageList(output)
	
	if len(languages) == 0 {
		s.logger.Debug("No subtitles available", zap.String("youtube_id", youtubeID))
		return []AvailableLanguage{}, nil
	}
	
	s.logger.Info("Found available languages",
		zap.String("youtube_id", youtubeID),
		zap.Int("count", len(languages)))
	
	return languages, nil
}

// parseLanguageList parses yt-dlp --list-subs output
func parseLanguageList(output string) []AvailableLanguage {
	var languages []AvailableLanguage
	lines := strings.Split(output, "\n")
	
	// Skip header lines and find the language list
	inLanguageSection := false
	for _, line := range lines {
		line = strings.TrimSpace(line)
		
		// Check if we're in the language section
		if strings.Contains(strings.ToLower(line), "available subtitles") || 
		   strings.Contains(strings.ToLower(line), "language") && strings.Contains(strings.ToLower(line), "formats") {
			inLanguageSection = true
			continue
		}
		
		if !inLanguageSection {
			continue
		}
		
		// Skip empty lines
		if line == "" {
			continue
		}
		
		// Parse language line
		// Format: "en       English vtt, ttml, srv3, srv2, srv1, json3"
		// or:     "en       English (auto-generated) vtt, ttml, ..."
		parts := strings.Fields(line)
		if len(parts) < 2 {
			continue
		}
		
		code := parts[0]
		isAutoGenerated := false
		var nameParts []string
		
		// Collect name parts (may contain spaces)
		for i := 1; i < len(parts); i++ {
			part := parts[i]
			lowerPart := strings.ToLower(part)
			
			// Check if this is a format indicator (starts with common formats)
			if strings.HasPrefix(lowerPart, "vtt") || 
			   strings.HasPrefix(lowerPart, "ttml") || 
			   strings.HasPrefix(lowerPart, "srv") ||
			   strings.HasPrefix(lowerPart, "json") {
				break
			}
			
			// Check for auto-generated marker
			if strings.Contains(lowerPart, "auto") || strings.Contains(lowerPart, "generated") {
				isAutoGenerated = true
				continue
			}
			
			// Remove parentheses if present
			part = strings.Trim(part, "()")
			if part != "" {
				nameParts = append(nameParts, part)
			}
		}
		
		if len(nameParts) == 0 {
			// Fallback: use code as name
			nameParts = []string{code}
		}
		
		name := strings.Join(nameParts, " ")
		
		// Capitalize first letter of each word
		words := strings.Fields(name)
		for i, word := range words {
			if len(word) > 0 {
				words[i] = strings.ToUpper(word[:1]) + strings.ToLower(word[1:])
			}
		}
		name = strings.Join(words, " ")
		
		languages = append(languages, AvailableLanguage{
			Code:            code,
			Name:            name,
			IsAutoGenerated: isAutoGenerated,
		})
	}
	
	return languages
}

func (s *Service) GetOrCreateTranscript(ctx context.Context, videoID uuid.UUID, languageCode ...string) (*models.Transcript, error) {
	// Check if transcript already exists (with specific language if provided)
	existing, err := s.transcriptRepo.GetByVideoID(ctx, videoID)
	if err == nil && existing != nil {
		// If language is specified and matches, return existing
		if len(languageCode) > 0 && languageCode[0] != "" {
			if existing.Language == languageCode[0] {
				return existing, nil
			}
			// Language doesn't match, continue to create new one
		} else {
			// No language specified, return existing
			return existing, nil
		}
	}

	// Get video info
	video, err := s.videoRepo.GetByID(ctx, videoID)
	if err != nil {
		return nil, errors.Wrap(err, errors.ErrorCodeVideoNotFound, errors.SubCodeVideoNotFound, "Video not found")
	}

	// Determine language to use
	lang := ""
	if len(languageCode) > 0 {
		lang = languageCode[0]
	}

	// Try YouTube captions first
	transcript, err := s.fetchYouTubeCaptions(ctx, video.YouTubeID, lang)
	if err == nil && transcript != nil {
		transcript.VideoID = videoID
		transcript.Source = "youtube"
		if err := s.transcriptRepo.Create(ctx, transcript); err != nil {
			return nil, err
		}
		s.updateVideoTranscriptStatus(ctx, videoID, true)
		return transcript, nil
	}

	// Fallback to Whisper - get provider from settings
	whisperProvider, err := s.providerFactory.GetWhisperProvider(ctx)
	if err != nil {
		return nil, errors.Wrap(err, errors.ErrorCodeProviderConfiguration, errors.SubCodeProviderConfigMissing, "Failed to get whisper provider")
	}
	
	if whisperProvider == nil {
		// YouTube provider selected, but captions not available
		return nil, fmt.Errorf("YouTube captions not available and no whisper provider configured")
	}

	transcript, err = s.transcribeWithWhisper(ctx, video.YouTubeID, whisperProvider)
	if err != nil {
		return nil, fmt.Errorf("failed to transcribe: %w", err)
	}

	transcript.VideoID = videoID
	transcript.Source = "whisper"
	if err := s.transcriptRepo.Create(ctx, transcript); err != nil {
		return nil, err
	}

	// Record token usage for transcription
	if s.costService != nil {
		modelInfo := whisperProvider.GetModelInfo()
		// Estimate tokens from transcript length
		estimatedTokens := len(transcript.Content) / 4
		
		_ = s.costService.RecordUsage(
			ctx,
			videoID,
			"transcription",
			modelInfo.Provider,
			modelInfo.Name,
			estimatedTokens,
			0,
		)
	}

	s.updateVideoTranscriptStatus(ctx, videoID, true)
	return transcript, nil
}

func (s *Service) fetchYouTubeCaptions(ctx context.Context, youtubeID string, languageCode string) (*models.Transcript, error) {
	url := fmt.Sprintf("https://www.youtube.com/watch?v=%s", youtubeID)
	
	s.logger.Info("Fetching YouTube captions", 
		zap.String("youtube_id", youtubeID),
		zap.String("language", languageCode))
	
	// Download captions
	captionPath := filepath.Join(s.tempDir, fmt.Sprintf("%s.%%(ext)s", youtubeID))
	
	cmdArgs := []string{
		"--write-auto-subs",     // Include auto-generated subtitles
		"--write-subs",           // Write subtitle file
		"--sub-format", "vtt",   // Use WebVTT format (easier to parse)
		"--skip-download",       // Don't download video/audio
		"--no-playlist",         // Don't download playlists
		"--quiet",               // Less verbose output
		"--no-warnings",         // Suppress warnings
		"-o", captionPath,     // Output path
	}
	
	// If language is specified, use it; otherwise let yt-dlp choose
	if languageCode != "" {
		cmdArgs = append(cmdArgs, "--sub-lang", languageCode)
	} else {
		// Default: prefer common languages, but let yt-dlp choose best available
		cmdArgs = append(cmdArgs, "--sub-lang", "en,en-US,en-GB,tr,de,fr,es,it,pt,ru,ja,ko,zh,ar,hi")
	}
	
	cmdArgs = append(cmdArgs, url)
	cmd := exec.Command("yt-dlp", cmdArgs...)
	
	var stderr bytes.Buffer
	cmd.Stderr = &stderr
	
	if err := cmd.Run(); err != nil {
		errorMsg := stderr.String()
		s.logger.Debug("Failed to download captions", 
			zap.String("youtube_id", youtubeID),
			zap.String("error", errorMsg),
			zap.Error(err))
		return nil, fmt.Errorf("failed to download captions: %w", err)
	}
	
	// Find the downloaded caption file
	pattern := filepath.Join(s.tempDir, fmt.Sprintf("%s.*.vtt", youtubeID))
	matches, err := filepath.Glob(pattern)
	if err != nil || len(matches) == 0 {
		// Try without language code
		pattern = filepath.Join(s.tempDir, fmt.Sprintf("%s.vtt", youtubeID))
		matches, err = filepath.Glob(pattern)
		if err != nil || len(matches) == 0 {
			return nil, fmt.Errorf("caption file not found after download")
		}
	}
	
	captionFile := matches[0]
	defer func() {
		// Clean up caption file
		if err := os.Remove(captionFile); err != nil {
			s.logger.Debug("Failed to cleanup caption file", zap.String("path", captionFile), zap.Error(err))
		}
	}()
	
	// Parse VTT file
	content, err := os.ReadFile(captionFile)
	if err != nil {
		return nil, fmt.Errorf("failed to read caption file: %w", err)
	}
	
	transcript, segments, detectedLang := parseVTT(string(content))
	
	if transcript == "" {
		return nil, fmt.Errorf("no transcript content found in captions")
	}
	
	// Use detected language or fallback to provided/requested language
	finalLang := detectedLang
	if finalLang == "" && languageCode != "" {
		finalLang = languageCode
	}
	if finalLang == "" {
		finalLang = "en" // Ultimate fallback
	}
	
	s.logger.Info("YouTube captions fetched successfully",
		zap.String("youtube_id", youtubeID),
		zap.String("language", finalLang),
		zap.Int("content_length", len(transcript)),
		zap.Int("segments", len(segments)))
	
	return &models.Transcript{
		Language: finalLang,
		Content:  transcript,
		Segments: models.TranscriptSegments(segments),
	}, nil
}

// parseVTT parses WebVTT format and extracts transcript text, segments, and language
func parseVTT(vttContent string) (string, []models.TranscriptSegment, string) {
	lines := strings.Split(vttContent, "\n")
	var transcript strings.Builder
	var segments []models.TranscriptSegment
	var detectedLang string
	
	var currentSegment *models.TranscriptSegment
	var segmentText strings.Builder
	
	for _, line := range lines {
		line = strings.TrimSpace(line)
		
		// Extract language from Language: line
		if strings.HasPrefix(line, "Language:") {
			langPart := strings.TrimPrefix(line, "Language:")
			langPart = strings.TrimSpace(langPart)
			if langPart != "" {
				// Extract language code (e.g., "en" from "Language: en" or "Language: en-US")
				langParts := strings.Fields(langPart)
				if len(langParts) > 0 {
					detectedLang = strings.ToLower(langParts[0])
				}
			}
			continue
		}
		
		// Skip VTT header and metadata
		if strings.HasPrefix(line, "WEBVTT") || 
		   strings.HasPrefix(line, "NOTE") ||
		   line == "" ||
		   strings.HasPrefix(line, "Kind:") {
			continue
		}
		
		// Parse timestamp line (format: 00:00:00.000 --> 00:00:05.000)
		if strings.Contains(line, "-->") {
			// Save previous segment if exists
			if currentSegment != nil && segmentText.Len() > 0 {
				currentSegment.Text = strings.TrimSpace(segmentText.String())
				segments = append(segments, *currentSegment)
				transcript.WriteString(currentSegment.Text)
				transcript.WriteString(" ")
				segmentText.Reset()
			}
			
			// Parse timestamps
			parts := strings.Split(line, "-->")
			if len(parts) == 2 {
				start := parseVTTTime(parts[0])
				end := parseVTTTime(parts[1])
				
				currentSegment = &models.TranscriptSegment{
					Start: start,
					End:   end,
				}
			}
			continue
		}
		
		// Text content
		if currentSegment != nil && line != "" {
			segmentText.WriteString(line)
			segmentText.WriteString(" ")
		}
	}
	
	// Save last segment
	if currentSegment != nil && segmentText.Len() > 0 {
		currentSegment.Text = strings.TrimSpace(segmentText.String())
		segments = append(segments, *currentSegment)
		transcript.WriteString(currentSegment.Text)
	}
	
	return strings.TrimSpace(transcript.String()), segments, detectedLang
}

// parseVTTTime parses VTT timestamp format (HH:MM:SS.mmm or MM:SS.mmm)
func parseVTTTime(timeStr string) float64 {
	timeStr = strings.TrimSpace(timeStr)
	
	// Remove any cue settings (e.g., "00:00:00.000 align:start position:0%")
	if idx := strings.Index(timeStr, " "); idx > 0 {
		timeStr = timeStr[:idx]
	}
	
	parts := strings.Split(timeStr, ":")
	if len(parts) < 2 {
		return 0
	}
	
	var hours, minutes, seconds float64
	
	if len(parts) == 3 {
		// Format: HH:MM:SS.mmm
		fmt.Sscanf(parts[0], "%f", &hours)
		fmt.Sscanf(parts[1], "%f", &minutes)
		fmt.Sscanf(parts[2], "%f", &seconds)
	} else {
		// Format: MM:SS.mmm
		fmt.Sscanf(parts[0], "%f", &minutes)
		fmt.Sscanf(parts[1], "%f", &seconds)
	}
	
	return hours*3600 + minutes*60 + seconds
}

func (s *Service) transcribeWithWhisper(ctx context.Context, youtubeID string, whisperProvider whisper.WhisperProvider) (*models.Transcript, error) {
	// Download audio using yt-dlp
	audioPath, err := s.downloadAudio(youtubeID)
	if err != nil {
		return nil, errors.Wrap(err, errors.ErrorCodeYouTubeDownload, errors.SubCodeYouTubeDownloadFailed, "Failed to download audio")
	}
	
	// Ensure audio file is cleaned up, even on error
	// Use a helper function to safely remove the file
	defer func() {
		if err := s.cleanupAudioFile(audioPath); err != nil {
			s.logger.Warn("Failed to cleanup audio file", 
				zap.String("path", audioPath), 
				zap.Error(err))
		}
	}()

	// Check file size - Groq has 25MB limit
	info, err := os.Stat(audioPath)
	if err != nil {
		return nil, fmt.Errorf("failed to get audio file info: %w", err)
	}

	// Groq API limit is 25MB (25 * 1024 * 1024 bytes)
	const groqMaxSize = 25 * 1024 * 1024
	modelInfo := whisperProvider.GetModelInfo()
	
	if modelInfo.Provider == "groq" && info.Size() > groqMaxSize {
		fileSizeMB := float64(info.Size()) / (1024 * 1024)
		maxSizeMB := float64(groqMaxSize) / (1024 * 1024)
		s.logger.Warn("Audio file too large for Groq API",
			zap.String("youtube_id", youtubeID),
			zap.Float64("file_size_mb", fileSizeMB),
			zap.Float64("max_size_mb", maxSizeMB),
			zap.String("suggestion", "Use local whisper provider in settings"))
		return nil, errors.ErrProviderFileTooLarge("groq", fileSizeMB, maxSizeMB)
	}

	// Transcribe with Whisper
	resp, err := whisperProvider.Transcribe(ctx, whisper.TranscribeRequest{
		AudioPath: audioPath,
		Task:      "transcribe",
	})
	if err != nil {
		return nil, errors.Wrap(err, errors.ErrorCodeWhisperAPI, errors.SubCodeWhisperAPIFailed, "Whisper transcription failed")
	}

	// Convert to transcript model
	segments := make([]models.TranscriptSegment, len(resp.Segments))
	for i, seg := range resp.Segments {
		segments[i] = models.TranscriptSegment{
			Start: seg.Start,
			End:   seg.End,
			Text:  seg.Text,
		}
	}

	return &models.Transcript{
		Language: resp.Language,
		Content:  resp.Text,
		Segments: models.TranscriptSegments(segments),
	}, nil
}

// DownloadAudio downloads audio for a YouTube video and returns the file path
func (s *Service) DownloadAudio(youtubeID string) (string, error) {
	return s.downloadAudio(youtubeID)
}

func (s *Service) downloadAudio(youtubeID string) (string, error) {
	url := fmt.Sprintf("https://www.youtube.com/watch?v=%s", youtubeID)
	outputPath := filepath.Join(s.tempDir, fmt.Sprintf("%s.%%(ext)s", youtubeID))

	// Clean up any existing files for this video ID before downloading
	// This prevents rename errors from yt-dlp
	cleanupPattern := filepath.Join(s.tempDir, fmt.Sprintf("%s.*", youtubeID))
	existingFiles, _ := filepath.Glob(cleanupPattern)
	for _, match := range existingFiles {
		// Skip .part files as they might be in use
		if !strings.HasSuffix(match, ".part") {
			if err := os.Remove(match); err != nil {
				s.logger.Debug("Failed to remove existing file", 
					zap.String("path", match), 
					zap.Error(err))
			}
		}
	}

	s.logger.Info("Downloading audio", 
		zap.String("youtube_id", youtubeID),
		zap.String("output_path", outputPath))

	cmd := exec.Command("yt-dlp",
		"-x",                    // Extract audio
		"--audio-format", "mp3", // Format
		"--no-playlist",         // Don't download playlists
		"--quiet",               // Less verbose output
		"--no-warnings",         // Suppress warnings
		"--no-mtime",            // Don't use modification time (prevents some file issues)
		"-o", outputPath,        // Output path
		url,
	)

	// Capture stderr for better error messages
	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		errorMsg := stderr.String()
		s.logger.Error("yt-dlp failed", 
			zap.String("youtube_id", youtubeID),
			zap.String("error", errorMsg),
			zap.Error(err))
		if errorMsg != "" {
			return "", errors.NewWithError(
				errors.ErrorCodeYouTubeDownload,
				errors.SubCodeYouTubeDownloadFailed,
				"Failed to download audio file",
				fmt.Errorf("yt-dlp: %s", errorMsg),
			)
		}
		return "", errors.Wrap(err, errors.ErrorCodeYouTubeDownload, errors.SubCodeYouTubeDownloadFailed, "Failed to download audio file")
	}

	// Find the actual output file
	pattern := filepath.Join(s.tempDir, fmt.Sprintf("%s.*", youtubeID))
	var matches []string
	matches, err := filepath.Glob(pattern)
	if err != nil {
		return "", fmt.Errorf("failed to find output file: %w", err)
	}
	if len(matches) == 0 {
		return "", fmt.Errorf("output file not found after download")
	}

	audioPath := matches[0]
	
	// Verify file exists and get size
	info, err := os.Stat(audioPath)
	if err != nil {
		return "", fmt.Errorf("downloaded file not accessible: %w", err)
	}
	
	s.logger.Info("Audio downloaded successfully",
		zap.String("youtube_id", youtubeID),
		zap.String("path", audioPath),
		zap.Int64("size_bytes", info.Size()))

	return audioPath, nil
}

// cleanupAudioFile safely removes an audio file, handling errors gracefully
func (s *Service) cleanupAudioFile(audioPath string) error {
	if audioPath == "" {
		return nil
	}

	// Check if file exists before trying to remove
	if _, err := os.Stat(audioPath); os.IsNotExist(err) {
		// File doesn't exist, nothing to clean up
		return nil
	}

	// Remove the file
	if err := os.Remove(audioPath); err != nil {
		return fmt.Errorf("failed to remove audio file: %w", err)
	}

	s.logger.Debug("Audio file cleaned up", zap.String("path", audioPath))
	return nil
}

func (s *Service) updateVideoTranscriptStatus(ctx context.Context, videoID uuid.UUID, hasTranscript bool) {
	video, err := s.videoRepo.GetByID(ctx, videoID)
	if err != nil {
		return
	}
	video.HasTranscript = hasTranscript
	s.videoRepo.Update(ctx, video)
}

